logger.quiet 'Running custom init.gradle file'

buildscript {
    allprojects {
        ext {
            stageOne = (false == properties.containsKey( 'stage' ) )|| (properties.get( 'stage').equalsIgnoreCase( 'ONE' ) )
            jacocoVersion = '0.6.3.201306030806'
            modsUrl = "http://192.168.254.81:81/artifactory/mods-release-local"
            publicationUsername = 'SVNBuild'
            publicationPassword = 'Snoopy*09'
            mavenCentralCacheUrl = "http://192.168.254.81:81/artifactory/repo1-cache"
            codehausCacheUrl = "http://192.168.254.81:81/artifactory/codehaus-cache"
            jbossCacheUrl = "http://192.168.254.81:81/artifactory/jboss-cache"
            springsourceCacheUrl = "http://192.168.254.81:81/artifactory/spring-release"
            springsourceMilestoneCacheUrl = "http://192.168.254.81:81/artifactory/spring-milestone"
            localCacheUrl = "http://192.168.254.81:81/artifactory/ext-release-local"
            localLibsCacheUrl = "http://192.168.254.81:81/artifactory/libs-release-local"
        }

        if ( project.properties.containsKey( 'project_version' ) ) {
            logger.quiet "Using specifed project_version of $project_version"
            status = 'release'
        }
        else
        {
            ext.project_version = '1.0.0-SNAPSHOT'
            logger.quiet "project_version not specified. Using default version of $project_version"
            status = 'integration'
        }
        project.version = project.project_version
        logger.quiet "version = $project.version"

        // we can no longer default the group name because we are running into name collisions
        // group = 'com.transparent'

        buildscript {
            repositories {
                maven {
                    name 'Experimental'
                    description 'Where to get internally published artifacts'
                    url = modsUrl
                }
            }
            dependencies {
                classpath group: 'org.kurron', name: 'tl-unified-build', version: '1.0.4'
            }
        }

        repositories {
            maven {
                name 'MavenCache'
                description 'Local Artifactory cache of Maven Central'
                url = mavenCentralCacheUrl
            }
            maven {
                name 'CodehausCache'
                description 'Local Artifactory cache of Codehaus'
                url = codehausCacheUrl
            }
            maven {
                name 'JbossCache'
                description 'Local Artifactory cache of JBOSS'
                url = jbossCacheUrl
            }
            maven {
                name 'SpringSourceCache'
                description 'Local Artifactory cache of SpringSource'
                url = springsourceCacheUrl
            }
            maven {
                name 'SpringSourceMilestoneCache'
                description 'Local Artifactory cache of SpringSource milestone builds'
                url = springsourceMilestoneCacheUrl
            }
            maven {
                name 'LocalReleaseCache'
                description 'Local repository for third party libraries'
                url = localCacheUrl
            }
            maven {
                name 'LocalLibsCache'
                description 'Local repository for third party libraries'
                url = localLibsCacheUrl
            }
            maven {
                name 'Sush-E'
                description 'Local Artifactory cache of TL artifacts'
                url = modsUrl
            }
        }

        if ( stageOne ) {
            // apply jacoco plugin outside of afterEvaluate block, or errors occur during build.
            logger.quiet 'Applying Jacoco plug-in...'
            apply plugin: 'jacoco'
            jacoco.toolVersion = jacocoVersion

            afterEvaluate { project ->
                logger.quiet( "Generating stage one tasks for $name project" )
                ext.isSnapshot = version.endsWith("-SNAPSHOT")


                if ( project.plugins.hasPlugin( WarPlugin ) ) {
                    war.manifest.attributes( "Implementation-Title": project.name, "Implementation-Version": project.version )
                }

                if ( project.plugins.hasPlugin( JavaPlugin ) )
                {
                    logger.quiet 'Java plugin detected!'
                    project.defaultTasks << 'build'

                    logger.quiet 'Configuring compiler options'
                    compileJava.options*.compilerArgs = ['-Xlint:deprecation','-encoding', 'UTF-8']
                    compileTestJava.options*.compilerArgs = ['-Xlint:deprecation','-encoding', 'UTF-8']

                    logger.quiet 'Configuring unit testing options'
                    test {
                        scanForTestClasses = false
                        includes = ['**/*UnitTest.class']
                        excludes = ['**/AbstractUnitTest.class']
                        maxParallelForks = Runtime.runtime.availableProcessors()
                    }

                    task collectJars(type: Copy) {
                        description 'Copy dependencies into build area for use by stage-two'
                        into "$buildDir/dependencies"
                        from( configurations.testRuntime )
                        doFirst { logger.quiet "Copying dependencies to $buildDir/dependencies" }
                    }
                    project.defaultTasks = ['collectJars'] + project.defaultTasks

                    logger.quiet 'Applying checkstyle plug-in'
                    project.plugins.apply( 'checkstyle' )
                    project.properties['checkstyle'].ignoreFailures = false
                    project.checkstyleMain.enabled = true
                    project.checkstyleTest.enabled = false
                    new File( "$buildDir" ).mkdirs()
                    project.checkstyle.configFile = file("${gradle.gradleHomeDir}/config/checkstyle.xml")
                    project.checkstyle.configProperties = [suppressionDirectory: projectDir.path ]

                    // create a manifest that's copied into each jar file
                    ext.sharedManifest = manifest {
                        attributes( "Implementation-Title": project.name, "Implementation-Version": project.version )
                    }

                    jar {
                        manifest = project.manifest {
                            from sharedManifest
                        }
                    }

                    task sourcesJar(type: Jar, dependsOn: classes) {
                        classifier = 'sources'
                        from sourceSets.main.allSource
                        exclude('**/*.properties')
                        manifest = project.manifest {
                            from sharedManifest
                        }
                    }

                    task testSourcesJar(type: Jar, dependsOn: testClasses) {
                        classifier = 'test-sources'
                        from sourceSets.test.allSource
                        exclude('**/*.properties')
                        manifest = project.manifest {
                            from sharedManifest
                        }
                    }

                    task testBinariesJar(type: Jar, dependsOn: testClasses) {
                        classifier = 'test'
                        from sourceSets.test.output
                        manifest = project.manifest {
                            from sharedManifest
                        }
                    }

                    task javadocJar(type: Jar, dependsOn: javadoc) {
                        classifier = 'javadoc'
                        from project.docsDir.path + '/javadoc'
                        manifest = project.manifest {
                            from sharedManifest
                        }
                    }

                    artifacts {
                        archives sourcesJar
                        archives testSourcesJar
                        archives testBinariesJar
                        archives javadocJar
                    }

                    logger.quiet 'Configuring Jacoco plug-in...'
                    jacocoTestReport {
                        reports {
                            xml.enabled true
                            csv.enabled false
                            html.enabled true
                        }
                    }

                    // Since the JaCoCo plug in does not honor excludes or break the build if coverage thresholds are crossed, we have to do it by hand.
                    task verifyCodeCoverage( dependsOn: 'jacocoTestReport' ) {
                        description = 'Parses the generated Jacoco xml report, and determines if sufficient coverage is present.'
                        group = 'Build'

                        doFirst {

                            // remove the DOCTYPE tag from the generated xml, otherwise we have to provide report.dtd ourselves.
                            def jacocoReportPath = "${jacoco.reportsDir}/test/jacocoTestReport.xml"
                            logger.quiet "Parsing generated Jacoco xml report found at $jacocoReportPath"
                            String xmlStr = new File( jacocoReportPath ).text.replace( '<!DOCTYPE report PUBLIC "-//JACOCO//DTD Report 1.0//EN" "report.dtd">', '' )
                            def xml = new XmlParser( false, false ).parse( new ByteArrayInputStream( xmlStr.bytes ) )

                            List jacocoExclude = project.properties.containsKey( 'coverageExcludes' ) ? project.ext.coverageExcludes : []
                            def filtered = xml.package.class.findAll { clazz -> !jacocoExclude.any { clazz.@name.contains( it ) } }
                            def instructions = filtered.collect{ it.counter }.flatten().findAll{ it.@type == 'INSTRUCTION' }.flatten()
                            def offenders = instructions.findAll { (it.@missed as int) >= (it.@covered as int) }.collect { it.parent().attributes().name }
                            offenders.each { logger.quiet "Insufficient code coverage: $it" }
                            if ( offenders ) {
                                throw new IllegalStateException( "Not enough code coverage! Consult ${jacoco.reportsDir}/test/html/index.html for details." )
                            }
                            else {
                                logger.quiet 'Adequate code coverage detected.'
                            }
                        }
                    }
                    check.dependsOn 'verifyCodeCoverage'

                    // the Maven plug-in only publishes if the Java plug-in is installed -- it is an unfixed bug
                    logger.quiet( "Applying Maven plug-in" )
                    project.plugins.apply( 'maven' )
                    if ( project.isSnapshot )
                    {
                        logger.quiet 'Snapshot revision detected. Adding install task to default.'
                        project.defaultTasks << 'install'
                    }
                    else
                    {
                        // this is the publishing plugin that is currently in incubation.  Works great
                        // but is limited to one artifact only.  We will switch over to this when it is
                        // done baking.
/*
                    logger.quiet 'Release revision detected. Applying maven-publish plug-in.'
                    project.plugins.apply( 'maven-publish' )
                    project.defaultTasks.add( 'publishMavenPublicationToMavenLocal' )
                    project.defaultTasks.add( 'publishMavenPublicationToMavenRepository' )

                    project.publishing {
                        repositories {
                            maven {
                                description 'Sandbox area of the repository to test publishing to'
                                url = modsUrl
                                credentials {
                                    username = publicationUsername
                                    password = publicationPassword
                                }
                            }
                        }
                    }
*/
                        logger.quiet 'Release revision detected. Adding uploadArchives to default tasks.'
                        project.uploadArchives {
                            repositories {
                                maven {
                                    description 'Where to publish artifacts to.'
                                    url = modsUrl
                                    credentials {
                                        username = publicationUsername
                                        password = publicationPassword
                                    }
                                }
                            }
                        }
                        project.defaultTasks << 'uploadArchives'

                    }
                }

                if ( project.plugins.hasPlugin( GroovyPlugin ) ) {
                    logger.quiet 'Groovy plugin detected!'

                    logger.quiet 'Applying codenarc plug-in'
                    project.plugins.apply( 'codenarc' )
                    new File( buildDir.path ).mkdirs()
                    project.codenarc.configFile = file( "${gradle.gradleHomeDir}/config/codenarc.xml" )
                    project.codenarc.ignoreFailures = false
                    project.codenarcMain.enabled = true
                    project.codenarcTest.enabled = false

                    task groovydocJar(type: Jar, dependsOn: groovydoc) {
                        classifier = 'groovydoc'
                        from project.docsDir.path + '/groovydoc'
                        manifest = project.manifest {
                            from sharedManifest
                        }
                    }

                    artifacts {
                        archives groovydocJar
                    }
                }

                if ( !project.plugins.hasPlugin( ProjectReportsPlugin ) ) {
                    logger.quiet 'Applying project-report plug-in'
                    project.plugins.apply( 'project-report' )
                    project.dependencyReport.enabled = true
                    project.propertyReport.enabled = true
                    project.taskReport.enabled = true
                }
            }
        } else {
            logger.quiet( name + ' Generating stage two tasks' )
        }
    }
}
